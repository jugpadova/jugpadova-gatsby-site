{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/articles/2006/05/14/enterprise-integration-with-ruby/",
    "result": {"data":{"site":{"siteMetadata":{"title":"JUG Padova"}},"markdownRemark":{"id":"80d2cec9-3618-5d29-83e2-baab1f0bb96e","excerpt":"Titolo: Enterprise Integration with RubyAutore: Maik\nSchmidtPagine: 346Anno: 2006Casa Editrice: The Pragmatic\nProgrammers LLC.ISBN: 0-9766940-6-9 Una recensione…","html":"<table>\n<tr>\n<td>\n<p><a href=\"/files/0976694069.jpg\"><img src=\"/files/0976694069.jpg\" alt=\"Cover: Enterprise Integration with Ruby\" width=\"120\" border=\"0\"/></a></p>\n</td>\n<td>\n<p>Titolo: Enterprise Integration with Ruby<br/>Autore: Maik\nSchmidt<br/>Pagine: 346<br/>Anno: 2006<br/>Casa Editrice: The Pragmatic\nProgrammers LLC.<br/>ISBN: 0-9766940-6-9<br/></p>\n</td>\n</tr>\n</table>\n<p>Una recensione di un libro su Ruby nel sito di un Java User Group?\nPerchè no? Inoltre il libro, almeno leggendo il titolo, parla di\nEnterprise Integration, un campo in cui Java la fa da padrone, almeno\nleggendo le parole dei markettari, quindi come minimo può essere utile\nper fare un confronto.</p>\n<p>Premetto che, almeno per ora, non programmo in Ruby e mi sono limitato\nsolamente all’installazione di Ruby on Rails e a provare pochi banali\nesempi. Al momento non sono convinto dell’effettiva utilità di Ruby e di\nRails, se non per uno sviluppo molto rapido, ma di applicazioni\npiuttosto semplici e “regolari”. Credo che quando la complessità aumenta\ne l’applicazione richiede funzionalità meno standard, gran parte dei\nvantaggi dell’addozione di Ruby rispetto a Java si perdano, ed anzi lo\nsviluppo possa diventare più complicato.</p>\n<p>…ma probabilmente mi sbaglio…e mi auguro che la lettura di questo\nlibro mi chiarisca un po’ le idee.</p>\n<p>Questa non vuole essere una vera e propria recensione, ma piuttosto un\ndiario di lettura. Sia perchè non ho voglia di scrivere qualcosa di\ntroppo organizzato, sia perchè fra qualche giorno devo passare il libro\nal nostro amico Paul Given (in arte Paolo Donà), che sarà sicuramente\ncapace di scrivere una recensione migliore della mia, dato che conosce\nmeglio Ruby.</p>\n<p>Ma passiamo al libro…<br>\n<em>[14 Maggio 2006…mattina]</em></p>\n<p>Iniziato, e letti tutti d’un fiato i primi due capitoli (Introduction e\nDatabases). Secondo l’introduzione il libro è adatto a me :) : “…for\nexperienced enterprise developers who know Java, C#, or C[]{.underline}\nbut don’t know much Ruby…“. Perfetto! Nell’introduzione non c’e’ molto\naltro, se non una breve descrizione di cosa si intende per enterprise\nsoftware ed enterprise integration. In tutto sette pagine, compresi i\nringraziamenti e un diagramma che descrive l’infrastruttura\ndell’applicazione d’esempio.</p>\n<p>Il secondo capitolo, dedicato ai database, è suddiviso in due parti: la\nprima dedicata ai database relazionali, la seconda all’accesso a servizi\ndi directory mediante LDAP. L’approccio usato dal libro, fedele allo\nstile della serie “Pragmatic Bookshelf”, è quello di mostrare molti\nesempi e molto codice, più che perdersi nella teoria. L’accesso ai\ndatabase viene spiegato usando, in sequenza, delle librerie ad-hoc per\nOracle e MySQL (contemporaneamente), una libreria con un’interfaccia\ngenerica indipendente dal DB (DBI), e un framework di mapping\nobject-relational, ActiveRecord.</p>\n<p>Nella parte su LDAP, si inizia con una breve introduzione alle\ncaratteristiche di tali database. Ne viene poi mostrato l’utilizzo in\nRuby, prima con la libreria Ruby/LDAP, e in seguito mediante ActiveLDAP,\nl’equivalente di ActiveRecord per il mapping object-hierachical.</p>\n<p>Il tutto è un discreto tutorial, di livello base, sulle tecniche di\naccesso a tecnologie enterprise, database in questo caso, in Ruby.\nPurtroppo non è esattamente quello che mi sarei aspettato da un libro\ncon questo titolo. Non vengono assolutamente affrontate le problematiche\ndi integrazione. L’unico spunto viene dato dal primo esempio, in cui si\naccede a dati presenti in due database differenti (uno Oracle e l’altro\nMySQL), ma senza comunque affrontare molti dei problemi che questo può\ncomportare. Ad esempio, non ci si preoccupa assolutamente della\ntransazionalità, risolta semplicemente attivando l’autocommit.</p>\n<p>Anche nel caso di LDAP, ci si limita all’accesso ad OpenLDAP, senza\nnessuna considerazione sulle problematiche di utilizzo di altri sistemi\ndi directory.</p>\n<p><em>[15 Maggio 2006…mattina]</em></p>\n<p>Il terzo capitolo si intitola “Processing XML”. Iniziare così il lunedì\nmattina? Noooo…passiamo oltre…cioè alla fine! :)</p>\n<p>L’ultimo capitolo, il sesto, si chiama “Tools and Techniques”…un po’\npiù stimolante.</p>\n<p>La prima sezione tratta di I18n e L10n. A quanto pare è attualmente un\npunto dolente di Ruby, dato che il supporto è minimo e assolutamente non\ncompleto. Comunque ci si può riuscire…facendo molta attenzione. A\nparte alcune soluzioni “artigianali” per il trattamento dei caratteri, e\nla citazione di un paio di librerie incomplete o non più mantenute\n(jcode e unicode), la parte interessante è l’esame della libreria ICU4R,\ndecisamente promettente. Per quanto riguarda la localizzazione dei\nmessaggi, viene suggerita la libreria Ruby-GetText, porting in Ruby\ndella GNU gettext. Francamente la trovo un po’ macchinosa. A parte le\nprobabili attuali limitazioni di Ruby in questo campo, che probablmente\nspariranno col tempo, per quanto riguarda il libro, mi sarei aspettato\nalmeno un accenno o un tentativo di integrazione con i sistemi di\nlocalizzazione di altri linguaggi, ad esempio con il meccanismo dei\nResourceBundle di Java…peccato.</p>\n<p>Segue una sezione sul logging, con l’esame delle librerie Logging e\nLog4R, l’equivalente il Ruby delle varie Log4J, Log4cpp, ecc. Niente da\ndire. Peccato anche in questo caso che non ci sia un tentativo, di\nriutilizzo-conversione almeno dei file di conversione delle liberie\ndelle altre famiglie.</p>\n<p>Molto interessante invece la sezione sulla creazione di deamon e\nservizi, sia in ambiente Unix, sia in ambiente Windows. Non c’e’ molto\nda dire su questo, ma, a parte RubyGems, per chi non lo conosce ancora,\nè sicuramente la sezione più eccitante del capitolo.</p>\n<p>Passando al processo di Build e Deployment, esamina setup.rb,\nl’equivalente in Ruby di autoconf, e RubyGems. Quest’ultimo è un sistema\nassolutamente comodo di installazione e di deployment, e, malgrado la\nmia scarsissima esperienza (ma anche nel libro si afferma questo), credo\nstia diventando il meccanismo standard di distribuzione di software\nRuby. Peccato venga trattato troppo brevemente, e solo per quanto\nriguarda l’installazione delle Gems. Ci si dilunga invece su setup.rb,\nmostrando anche come costruire un pacchettizzazione di un piccolo\nprogetto con questo tool.</p>\n<p>La sezione successiva tratta dell’automazione del progetto, cioè del\nprocesso di sviluppo. Viene suggerito sono Rake, l’equivalente in Ruby\ndi make. Paragonato con i tool presenti in Java (ad esempio Ant e Maven)\nè decisamente un passo indietro. Brevemente: non portabile e con una\nsintassi macchinosa come quella del make originale. Se non ricordo male,\nesistono altri tool a questo scopo (un grazie a chi me li ricorda :) ).</p>\n<p>L’ultima sezione è un tentativo di eseguire dei system test sulle\napplicazioni legacy. Il risultato è poco più dell’automazione di una\nserie di diff sull’output delle applicazioni, confrontato con l’output\ndi un’esecuzione precedente. Niente che non potesse essere realizzato\ncon un normale shell script, senza scomodare Ruby. Discutibile anche la\nscelta di utilizzare YAML per la descrizione del testcase, invece di un\ncomune file XML.</p>\n<p><em>[16 Maggio 2006…mattina]</em></p>\n<p>Ok…coraggio…vediamo sto capitolo su XML (si capisce che odio l’XML?\n:) ) …ma purtroppo è un male necessario, e, quando non se ne abusa con\nl’utilizzo, anche utile.</p>\n<p>Il capitolo tutto sommato non è male. Ovviamente introduce,\nfortunatamente molto brevemente, le basi dell’XML, per poi passare alla\ngenerazione, parsing e validazione in Ruby. C’è anche una sezione\ndedicata a XPath, che forse poteva essere evitata, o almeno ridotta (a\nchi potrà mai interessare una tabella, che occupa metà di una pagina,\ndegli operatori booleani di XPath: =, !=, >, ecc…?)</p>\n<p>Il primo approccio alla generazione è quello “artigianale” mediante\nconcatenazione di stringhe. Ovviamente sconsigliato anche dallo stesso\nautore, ma è comunque un modo per concentrarsi sui problemi di\ngenerazione dell’XML e un buon esempio di codice Ruby sul trattamento\ndelle stringhe. Successivamente viene mostrato come si dovrebbe fare\n“sul serio”, mediante la libreria\n[REXML](<a href=\"http://www.ruby-doc.org/stdlib/libdoc/rexml/rdoc/\">http://www.ruby-doc.org/stdlib/libdoc/rexml/rdoc/</a>) e mediante\nla libreria [Builder](<a href=\"http://builder.rubyforge.org/\">http://builder.rubyforge.org/</a>).</p>\n<p>Passando alla elaborazione/parsing di documenti XML, viene mostrato\nl’utilizzo di REXML, che supporta sia un tree parsing (proprietario, non\nDOM standard), sia due metodi di stream parsing, uno proprietario e\nquello SAX2. Il supporto a quest’ultimo è molto buono, a parte ciò che\nha a che fare con il DTD. Inoltre si evidenziano alcuni vantaggi\nderivanti dall’utilizzo di un linguaggio dinamico come Ruby, che evita\nalcune delle “noiosità” sintattiche di un linguaggio statico e\nfortemente tipizzato come Java.</p>\n<p>Viene poi mostrato l’utilizzo di una libreria per l’XML binding, tipo\n[XMLBeans](<a href=\"http://xmlbeans.apache.org\">http://xmlbeans.apache.org</a>), per capirci. La libreria si\nchiama [XmlSimple](<a href=\"http://rubyforge.org/projects/xml-simple/\">http://rubyforge.org/projects/xml-simple/</a>), ed è il\nporting in Ruby del modulo Perl XML:Simple. Peccato che il risultato sia\nassolutamente equivalente al progetto Perl originale: una serie di array\ne hashmap. Con le possibilità di generazione dinamica di Ruby mi sarei\naspettato qualcosa di più. Possibile che non esista niente di meglio?</p>\n<p>Segue la nota dolente dell’attuale supporto XML di Ruby: la validazione.\nParaticamente nulla, almeno per le librerie esaminate in questo libro.\nREXML supporta parzialmente RELAX NX, ma per nulla DTD e Schema. Se\nproprio serve (? certo che serve!), nel libro viene suggerito di\ninvocare un tool esterno a riga di comando: xmllint.</p>\n<p>In conclusione del capitolo vengono presentate, con esempi di codice\nRuby, le alternative all’uso di XML: CSV, Properties Files alla Java e\n(entusiasticamente) YAML. Personalmente non condivido l’entusiasmo per\nYAML…</p>\n<p><em>[19 Maggio 2006…mattina]</em></p>\n<p>Mooolto interessante il capitolo 5 “Low-Ceremony Distributed\nApplications”. Con questa dicitura l’autore intende applicazioni in\ngrado di comunicare all’esterno con dei protocolli molto semplici.</p>\n<p>Viene quindi mostrato come costruire dei semplici TCP server\nmulti-thread. Mediante la libreria gserver, il tutto si risolve in\nveramente poche righe di codice. Gi esempi costruiscono un semplice log\nserver, di cui vengono scritti i client in Ruby (ovviamente), Java e\nPerl. In seguito al server vengono aggiunte le capacità di memorizzare\nle voci di log in un database con ActiveRecord, e di spedire un’e-mail\nin caso di logging di un fatal error. La libreria usata in questo caso è\n[tmail](<a href=\"http://raa.ruby-lang.org/project/tmail/\">http://raa.ruby-lang.org/project/tmail/</a>).</p>\n<p>La seconda parte del capitolo si dedica invece ad applicazioni che\ncomunicano tramite il protocollo HTTP. Viene quindi mostrato come\nscrivere dei client e dei server HTTP. Quest’ultimo compito viene rese\nquasi banale dall’utilizzo della libreria\n[WEBrick](<a href=\"http://www.webrick.org/\">http://www.webrick.org/</a>). In pochi secondi si riesce a\nmettere in piedi un server HTTP, eventualmente con supporto SSL, vari\ntipi di autenticazione, la capacità di leggere le password dallo stesso\nfile di Apache httpd, e molto altro.</p>\n<p><em>[20 Maggio 2006…mattina]</em></p>\n<p>Lettura veloce del capitolo 5 “Distributed Applications with RPC”, dato\nche fra qualche ora devo mollare il libro a Paolo.</p>\n<p>Anche questo, come il capitolo 4, è uno dei capitoli per cui secondo me\nvale la pena di leggere il libro. In una sessantina di pagine viene\nmostrato come usare in Ruby praticamente tutte le tecnologie per\nintefacciarsi con applicazioni scritte in altri linguaggi (e viceversa):\nXML-RPC, HTTP/REST, SOAP, CORBA e RMI.</p>\n<p>Interessante, soprattutto dal punto di vista dell’integrazione,\nl’approccio per CORBA (l’uso di RMI non viene mostrato, dato che è\nottenibile nella stessa maniera).<br>\nDato che non esiste, e probabilmente non esisterà mai,\nun’implementazione di CORBA per Ruby…viene usata l’implementazione\ncorba di Java, usando direttamente una JVM e le classi Java da Ruby,\nmediante [rjb](<a href=\"http://raa.ruby-lang.org/project/rjb/\">http://raa.ruby-lang.org/project/rjb/</a>) (Ruby Java\nBridge). rjb usa la Java Native Interface per istanziare qualunque\nclasse Java da Ruby.</p>\n<p>Infine viene mostrato l’uso di\n[dRuby](<a href=\"http://raa.ruby-lang.org/project/druby/\">http://raa.ruby-lang.org/project/druby/</a>), l’equivalente in\nRuby dell’RMI in Java…decisamente sconsigliato, se l’obiettivo è\nl’interoperabilità con altri linguaggi.</p>\n<p>Concludendo…il libro è sicuramente da consigliare, soprattutto a chi\nnon conosce molto Ruby, e vuole farsi un’idea di come potrebbe essere\nutilizzato in un ambiente eterogeneo. Il livello non è sicuramente\navanzato, ma intermedio, e questo è un peccato: in alcuni argomenti si\nsarebbe potuto andare un po’ più a fondo. La critica principale da fare\nè che generalmente tende ad essere una mera esposizione con esempi delle\nlibrerie disponibili in Ruby per usare le tecnologie che normalmente si\nusano in ambiente enterprise. Mi sarei aspettato un’attenzione maggiore\nai problemi che si incontrano affrontando l’integrazione in ambiente\nenterprise.</p>\n<p>Ad esempio, nella sezione su SOAP viene semplicemente mostrato come\ncreare un servizio SOAP in Ruby. Possibile che non ci sia proprio nessun\nproblema o difficoltà ad usare tale servizio da client .NET o Java? O,\nviceversa, che non si debba usare qualche accortezza se dobbiamo\naccedere a servizi SOAP scritti in .NET o Java usando un client scritto\nin Ruby?</p>","frontmatter":{"title":"Enterprise Integration with Ruby","date":"14 maggio 2006","description":null,"author":{"username":"lucio.benfante","fullname":"Lucio Benfante","email":"lucio.benfante@jugpadova.it"},"categories":[{"name":"Recensioni","permalink":"recensioni"}],"tags":[{"name":"ruby","display":"ruby"},{"name":"enterprise","display":"enterprise"},{"name":"integration","display":"integration"}]}},"previous":{"fields":{"slug":"/articles/2006/04/30/jug-meeting-28-da-java-a-ruby-e-ritorno/"},"frontmatter":{"title":"JUG Meeting #28 - \"Da Java a Ruby e ritorno\""}},"next":{"fields":{"slug":"/articles/2006/05/17/findbugs-to-discover-bugs/"},"frontmatter":{"title":"findbugs to discover bugs"}}},"pageContext":{"id":"80d2cec9-3618-5d29-83e2-baab1f0bb96e","previousPostId":"be758963-1047-5866-aa68-6be3f820ade1","nextPostId":"e5f1f16d-619e-5dc4-8241-80f75c066078"}},
    "staticQueryHashes": ["2841359383"]}